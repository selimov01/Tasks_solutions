'''
Скалярное произведение двух векторов одинакового размера — это сумма произведений соответствующих координат.

В поиске одним из шагов генерации выдачи является расчет скалярного произведения двух целочисленных векторов Q и D. Первый вектор вычисляется, исходя из запроса, а второй — исходя из документа. Каждая координата векторов — беззнаковое целочисленное 4-байтовое число. Размер обоих векторов N.

Документные вектора хранятся в поисковом индексе. В целях экономии места их координаты сжимаются до одного байта по следующему алгоритму:
A = min_i D_i
B = max_i D_i
C_i = { ⌊(255(D_i − A)) / (B−A)⌋, если A < B; 0, иначе }
 
Здесь ⌊x⌋ обозначает округление вниз до ближайшего целого числа (⌊5⌋=5, ⌊6.99⌋=6). 
Таким образом, вектор D преобразится в вектор C того же размера, но каждая координата которого будет принимать целые значения от 0 до 255.
Например, если исходный вектор D = (1000, 2000, 3000, 4000, 5000), то A = 1000, B = 5000, и C = (0, 63, 127, 191, 255).

Ваша задача — посчитать скалярное произведение векторов Q и D, но имея на руках только сжатый вектор C (а так же значения A и B) вместо исходного вектора D.

Формат ввода
В первой строчке указан размер векторов N (1 ≤ N ≤ 64).
Во второй строчке через пробел указаны целочисленные координаты исходного запросного вектора 
Q (0 ≤ Q_i ≤ 10^8)
В третьей строчке через пробел указаны целочисленные координаты сжатого документного вектора 
C (0 ≤ C_i ≤ 255)

В четвертой строчке через пробел указаны целые значения A и B(0 ≤ A ≤ B ≤ 10^8).

Формат вывода
В качестве ответа надо вывести единственное целое число — скалярное произведение исходных векторов. Ответ будет считаться корректным, если ∣dot(Q,D) − ans∣ ≤ ∑((Q ∗ (B − A)) / 255), где dot(Q,D) — истинное скалярное произведение исходных векторов, а ans — ответ участника.
'''

N = int(input())
Q = list(map(int, input().split()))
C = list(map(int, input().split()))
A, B = map(int, input().split())

dot = 0
if A < B:
    for i in range(N):
        Di = A + (C[i] * (B - A)) / 255
        dot += Q[i] * Di
if A == B:
    for i in range(N):
        dot += Q[i] * A

print(round(dot))