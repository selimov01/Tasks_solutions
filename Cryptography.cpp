/*
Мастер Олег разработал, по его мнению, весьма защищенный итеративный метод кодирования текстовых данных с использованием перестановок. Метод использует особенности вычисления остатков при умножении в арифметике по простому модулю.

Напомним, что если p – простое, тогда для трех чисел x, y и a (0 ≤ a, x, y < p, x != y) верно выражение ax != ay.

Метод Олега применяется к строке s длиной n символов и состоит из двух этапов:
1) Выбрать минимальное простое число p (p≥n). Добавить в конец строки s ровно p−n символов ‘.’.
2) Выполнить k проходов перестановочного алгоритма. После j-й итерации (1 ≤ j ≤ k) на i-й позиции строки оказывается символ, расположенный до этой итерации на позиции i⋅j(modp). Позиции в строке нумеруются от 0.

Продемонстрируем на примере. Пусть исходная строка s была ‘cypher’. После первой фазы алгоритма строка будет равна ‘cypher.’. Пусть количество проходов алгоритма k=3. После первого прохода – j=1 – строка не изменится. После второго прохода – j=2 – строка будет равна ‘cpe.yhr’. Итоговая строка будет равна ‘c.rehpy’.

Для заданной строки и параметра k определите результат шифрования.

Формат ввода
В первой строке записаны два целых числа n и k (1 ≤ k < n ≤ 1000000).
Во второй строке записана строка s, состоящая из n больших и маленьких букв английского алфавита.

Формат вывода
Выведите результат шифрования.
*/

#include <iostream>
#include <string>

using namespace std;

bool is_prime(int num)
{
    if (num <= 1)
        return false;
    if (num == 2)
        return true;
    if (num % 2 == 0)
        return false;
    for (int d = 3; d * d <= num; d += 2)
    {
        if (num % d == 0)
            return false;
    }
    return true;
}

int find_smallest_prime(int n)
{
    if (n <= 2)
        return 2;
    int candidate = n;
    if (candidate % 2 == 0)
        candidate++;
    while (true)
    {
        if (is_prime(candidate))
            return candidate;
        candidate += 2;
    }
}

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int n, k;
    string s;
    cin >> n >> k;
    cin.ignore();
    getline(cin, s);

    const int p = find_smallest_prime(n);
    s.append(p - n, '.');

    long long T = 1;
    for (int j = 1; j <= k; j++)
    {
        T = (T * j) % p;
    }

    string result(p, '\0');
    for (int i = 0; i < p; i++)
    {
        result[i] = s[(i * T) % p];
    }

    cout << result << '\n';
    return 0;
}