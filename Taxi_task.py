'''
При вызове такси мы не всегда можем сказать точно, за сколько времени таксист может доехать до пользователя. В этой задаче вам нужно разработать алгоритм, который будет определять, какие таксисты смогут гарантированно добраться до точки заказа за отведенное время, если примут его моментально. Таксист может стоять на месте или перемещаться по кругу по часовой стрелке, поэтому на момент вызова его позиция может измениться по сравнению с последней известной — он мог двигаться с любой скоростью, вплоть до максимально разрешенной. Точка заказа и точки, в которых находятся или могут находиться таксисты, — это точки на круге, перемещаться на вызов такси может только по часовой стрелке.

Формат ввода
В первой строке задано три целых числа: число событий N, длина круга L (в метрах), по которому перемещаются таксисты и на котором происходят заказы, максимальная скорость S с которой такси могут перемещаться по кругу. В последующих N строках описываются события в следующем формате:
TAXI <timestamp> <taxi_id> <taxi_position>. Команда, оповещающая о том, что таксист с номером 
taxi_id в момент времени timestamp прислал координату своего местоположения. Местоположение определяется значением taxi_position — целым числом в диапазоне [0,L), где 0 означает, что такси стоит в начале круга, а любое положительное число — дальность позиции таксиста от начала круга при движении по часовой стрелке.
ORDER <timestamp> <order_id> <order_position> <order_time>. Команда, оповещающая о том, что в момент времени timestamp пришёл заказ order_id на точку А, определяющуюся значением order_position — целым числом в диапазоне [0,L) (где 0 означает, что заказ произошел в начале круга, а любое положительное число — дальность позиции вызова от начала круга при движении по часовой стрелке), до которого нужно гарантированно доехать за order_time секунд.

Поле timestamp — это unix-like секундный таймстемп, все приходящие команды отсортированы по нему в порядке возрастания. Возрастание нестрогое: в нескольких последовательных командах могут быть одинаковые таймстемпы, но на момент события вызова мы рассматриваем только те события, которые нам известны (то есть не рассматриваем события, которые пришли после вызова, даже если у них такой же таймстемп). 

Все заказы пронумерованы (order_id), начиная с 0 в порядке их появления.

Ограничения:
N ≤ 5000;
0 < L ≤ 100000 (в метрах);
0 < S ≤ 10 (в метрах в секунду);
0 ≤order_time ≤ L (в секундах);
0 ≤ taxi_id < N (число от N).

Формат вывода
Программа должна вывести K строк, где K — количество команд ORDER.

В ответ на каждую команду ORDER программа должна вывести строку с таксистами (набор taxi_id, разделённых пробелами), которые гарантированно смогут добраться до точки А не более чем за order_time. Если таких таксистов больше 5, то нужно вывести 5 любых. Если ни один таксист не может гарантировано приехать в отведённое время, то в строке должен быть единственный идентификатор −1. 
Идентификаторы в одной строке не должны повторяться.
'''

first_line = input().strip().split()
N = int(first_line[0])
L = int(first_line[1])
S = int(first_line[2])

taxi_info = {}
order_res = [] 

for _ in range(N):
    event = input().strip().split()
    event_type = event[0]
    timestamp = int(event[1])

    if event_type == 'TAXI':
        taxi_id = int(event[2])
        taxi_position = int(event[3])
        taxi_info[taxi_id] = {'last_time': timestamp, 'last_pos': taxi_position}
        
    elif event_type == 'ORDER':
        order_id = int(event[2])
        order_pos = int(event[3])
        order_time = int(event[4])

        valid_taxi = set()
        for id in taxi_info:
            
            last_time = taxi_info[id]['last_time']
            last_pos = taxi_info[id]['last_pos']
            delta_time = timestamp - last_time
            max_distance = delta_time * S

            min_pos = last_pos % L
            max_pos = (last_pos + max_distance) % L

            if min_pos <= max_pos:
                
                if min_pos <= order_pos <= max_pos:
                    distance = (order_pos - min_pos) % L
                    if distance <= order_time * S:
                        valid_taxi.add(id)
            else:
            
                if order_pos >= min_pos or order_pos <= max_pos:
                    distance = min((order_pos - min_pos) % L, (max_pos - order_pos) % L)
                    if distance <= order_time * S:
                        valid_taxi.add(taxi_id)

        if not valid_taxi:
            order_res.append("-1")
            
        else:
            sorted_taxis = sorted(valid_taxi)
            result = ' '.join(map(str, sorted_taxis[:5]))
            order_res.append(result)

for result in order_res:
    print(result)